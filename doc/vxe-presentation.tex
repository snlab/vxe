\documentclass[aspectratio=169, notes]{beamer}

\usetheme{default}

\author{
	S.~Chen\inst{1},
	K.~Gao\inst{2},
	X.T.~Wang\inst{1} and
	J.J.~Zhang\inst{1}}
\institute{
	\inst{1}{
		Tongji University
	}
	\inst{2}{
		Tsinghua University
	}
}

\title{Virtual eXecution Environment for SDN}

\begin{document}

\begin{frame}
	\titlepage
	\note{
		Hello, everyone! Nice to meet you all!

		I'm Kai, a Ph.D student at Tsinghua University and my teammates are
		Shenshen, Tony and Jensen who are all from Tongji University.  Today we
		are going to present the \emph{Virtual eXecution Environment} for SDN
		programming, which is aimed to solve the data consistency problem in the
		control plane and to simplify programming in SDN.
	}
\end{frame}

\begin{frame}{Outline}
	\tableofcontents

	\note{
		Here is the outline of our presentation.

		First we discuss a little bit about what kind of problems we are trying
		to solve and why current solutions are not good enough.

		Second we introduce the overall design of our blueprint and show what we
		have implemented during the ONUG competition.

		Finally we walk through the code and present a demo of the system.
	}
\end{frame}

\section{Problem Statement}

\begin{frame}{Problem Statement}

	\begin{itemize}
		\item Data consistency in the control plane
		\item Complexity in SDN programming
	\end{itemize}

	\note{
		Our group has been working on the problem of SDN programming models, in
		the sense that we want to understand how SDN programming differs from
		generic programming by identifying domain-specific features, and to
		design a programming framework that satisfies the demand of correctness,
		efficiency and simplicity.

		In this presentation we discuss mainly about two issues that are
		identified: the data consistency in the control plane and the
		programming complexity in modern SDN systems.
	}

\end{frame}

\begin{frame}{Data Consistency in the Control Plane}

	\note{
		Most SDN applications depend on certain network states or user
		configurations and their final output includes resource allocations and
		forwarding rules on devices.  All these input and output are modelled as
		\emph{data} and the problem of data consistency has two meanings:

		First, the data should be synchronized on different machines.  Most
		modern controllers have provided mechanism such as distributed data base
		to solve this.

		Second, the output of an application should be consistent with the
		input, which means if the input of the application changes, the output
		may need to be updated.

		Modern SDN controllers have provided the abstraction of datastore to
		help solve these two consistency problems.  However, the mechanisms they
		provide are low-level operations and make SDN programming complex.
	}

	\begin{itemize}
		\item Programs in the network are \emph{data-centric}:
			\begin{itemize}
				\item Input: \emph{network states}, \emph{user configurations},
					...
				\item Output: \emph{resource allocation}, \emph{device
					configurations}, ...
			\end{itemize}
		\item Two kinds of \emph{data consistency}:
			\begin{itemize}
				\item Different copies have identical values on distributed
					machines.
				\item The output of a program should be consistent
					with the input.
			\end{itemize}
		\item Current solutions: the abstraction of \emph{datastore}
			\begin{itemize}
				\item Onix, OpenDaylight, ONOS, ...
			\end{itemize}
	\end{itemize}

\end{frame}

\begin{frame}{Programming Complexity}

	\note{
		The complexity of SDN programming can affect the following aspects:

		First is the development.

		For example, to guarantee the data consistency we talked about in the
		last slide, programmers must identify dependent data in the program,
		register listeners to manage data changes and be very careful with
		allocated resources.  Common techniques such as asynchronous I/O and
		multi-threading may also lead to programming complexities.

		Second is debugging.

		Programming complexities often result in difficulty in reading the
		source code, which makes it extremely hard to debug.  Also when a new
		program is being tested in a real network, we want to make sure its
		consequence is traceable and controllable.

	}

	\begin{itemize}
		\item Development considerations:
			\begin{itemize}
				\item For \emph{data consistency}: identify dependent data,
					manage data changes and resources
				\item For \emph{performance}: asynchronous I/O, multi-threading, ...
				\item ...
			\end{itemize}
		\item Debugging considerations:
			\begin{itemize}
				\item \emph{Source code}: readability
				\item \emph{Runtime debugging}: data provenance, sandbox, ...
			\end{itemize}
	\end{itemize}

\end{frame}

\section{Overall Design}

\begin{frame}{Motivations}

	\note{
		Our project is motivated by the following observations:

		First, data consistency is an important property in the control plane
		and should not be compromised.

		Second, identifying data dependencies, as well as dealing with data
		changes or managing allocated resources, can and should be handled
		automatically, beyond the programmers' concern.

		Finally, for debugging and security reasons, it is important to trace
		and to control the behaviours and possible consequences of SDN programs.

		Thus we propose the VXE system, hoping to achieve all the three targets.
	}

	\begin{itemize}
		\item Critical properties such as the data consistency \emph{must not be
			compromised}.
		\item The requirements for data consistency \emph{should be transparent to
			programmers}.
		\item The behaviours of programs \emph{must be traceable and
			controllable}.
	\end{itemize}
\end{frame}

\section{Demo Project}

\begin{frame}{The Prototype}

	\note{
		In the ONUG competition, we have implemented a simple version of the VXE
		system to demonstrate the basic workflow.  This prototype system is
		built on top of the OpenDaylight controller and we have implemented an
		application to calculate the shortest path between two specific end
		hosts and to set up the path using OpenFlow.

		For simplicity, all the components are implemented in one single module.
		When the module is loaded, it will initialize the simplified VXE system.

		Users can use RESTCONF to invoke a RPC which eventually creates the
		corresponding tasklet and submits it to the VXE system.

		We also skip the step of information flow analysis in this demo and
		simply mark all the accessed data as dependent.  Since we are using the
		OpenDaylight datastore API, the runtime will register data change
		listeners automatically.

		As we can see from the source code, the programmers don't have to worry
		about the data consistency.
	}

	\begin{itemize}
		\item The demo system is highly customized for OpenDaylight.
	\end{itemize}

\end{frame}

\begin{frame}{Components}
\end{frame}

\begin{frame}{Workflow}
\end{frame}

\section{Thank-you}

\begin{frame}
	\begin{center}
		\Large{Q \& A}
	\end{center}
\end{frame}

\end{document}
